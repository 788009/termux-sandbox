#!/data/data/com.termux/files/usr/bin/bash

# ================= Configuration =================
SANDBOX_NAME="${2:-default}"
SANDBOX_BASE="$HOME/.termux-sandbox/$SANDBOX_NAME"
ARCH=$(dpkg --print-architecture)

BOOTSTRAP_VERSION="bootstrap-2025.11.30-r1%2Bapt.android-7"
BOOTSTRAP_URL_ARM="https://github.com/termux/termux-packages/releases/download/${BOOTSTRAP_VERSION}/bootstrap-arm.zip"
BOOTSTRAP_URL_AARCH64="https://github.com/termux/termux-packages/releases/download/${BOOTSTRAP_VERSION}/bootstrap-aarch64.zip"

# Busybox configuration
BUSYBOX_URL="https://github.com/788009/termux-sandbox/releases/download/v1.0/busybox_arm64"
BUSYBOX_PATH="$HOME/busybox_arm64"
TARGET_DOMAIN="packages-cf.termux.dev"
# ===============================================

get_bootstrap_url() {
    case "$ARCH" in
        arm) echo "$BOOTSTRAP_URL_ARM" ;;
        aarch64) echo "$BOOTSTRAP_URL_AARCH64" ;;
        *) echo "Unsupported arch: $ARCH"; exit 1 ;;
    esac
}

find_busybox() {
    if [ -f "$BUSYBOX_PATH" ]; then echo "$BUSYBOX_PATH"; return; fi
    SCRIPT_DIR=$(dirname "$(realpath "$0")")
    if [ -f "$SCRIPT_DIR/busybox_arm64" ]; then echo "$SCRIPT_DIR/busybox_arm64"; return; fi
    return 1
}

# Check and automatically download Busybox if missing
check_busybox() {
    local EXIST_PATH=$(find_busybox)
    
    # If exists, return immediately
    if [ -n "$EXIST_PATH" ]; then
        return 0
    fi

    echo "[!] Busybox binary not found."
    
    # Architecture check (simple check to prevent downloading on non-arm64)
    if [ "$ARCH" != "aarch64" ]; then
        echo "[!] Warning: Auto-download is configured for aarch64. Your arch is $ARCH."
    fi

    echo "[+] Downloading Busybox from release..."
    curl -L "$BUSYBOX_URL" -o "$BUSYBOX_PATH" --fail

    if [ $? -ne 0 ]; then
        echo "[!] Error: Failed to download Busybox. Please install it manually."
        rm -f "$BUSYBOX_PATH"
        exit 1
    fi

    chmod 755 "$BUSYBOX_PATH"
    echo "[+] Busybox installed to $BUSYBOX_PATH"
}

restore_symlinks() {
    local TARGET_DIR="$1"
    local SYMLINKS_FILE="$TARGET_DIR/SYMLINKS.txt"
    if [ ! -f "$SYMLINKS_FILE" ]; then return; fi
    echo "[+] Restoring symlinks..."
    cd "$TARGET_DIR" || return
    ln -sf coreutils bin/env
    ln -sf bash bin/sh
    awk -F '‚Üê' '{system("ln -sf " $1 " " $2)}' "$SYMLINKS_FILE" 2>/dev/null
}

resolve_ip() {
    ping -c 1 "$1" 2>/dev/null | grep -oE '\([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+\)' | head -n 1 | tr -d '()'
}

check_dns() {
    if ping -c 1 -W 1 8.8.8.8 >/dev/null 2>&1; then echo "8.8.8.8"; else echo "114.114.114.114"; fi
}

compile_fake_uid() {
    local LIB_DIR="$SANDBOX_BASE/data/data/com.termux/files/usr/lib"
    mkdir -p "$LIB_DIR"
    echo "[*] Compiling UID spoofer..."
    cat > "$SANDBOX_BASE/fake_uid.c" <<EOF
#define _GNU_SOURCE
#include <unistd.h>
#include <sys/types.h>
uid_t getuid(void) { return 10000; }
uid_t geteuid(void) { return 10000; }
gid_t getgid(void) { return 10000; }
gid_t getegid(void) { return 10000; }
EOF
    if command -v clang >/dev/null; then
        clang -shared -fPIC "$SANDBOX_BASE/fake_uid.c" -o "$LIB_DIR/libfakeuid.so"
    elif command -v gcc >/dev/null; then
        gcc -shared -fPIC "$SANDBOX_BASE/fake_uid.c" -o "$LIB_DIR/libfakeuid.so"
    else
        echo "[!] Error: 'clang' or 'gcc' is required on host."
        exit 1
    fi
    rm "$SANDBOX_BASE/fake_uid.c"
}

cmd_create() {
    echo "[*] Creating sandbox: $SANDBOX_NAME"
    TERMUX_USR="$SANDBOX_BASE/data/data/com.termux/files/usr"
    TERMUX_HOME="$SANDBOX_BASE/data/data/com.termux/files/home"
    TERMUX_CACHE="$SANDBOX_BASE/data/data/com.termux/cache"
    
    if [ -d "$TERMUX_USR/bin" ]; then echo "[!] Environment exists."; exit 0; fi
    
    # Ensure Busybox is available
    check_busybox
    
    LOCAL_BUSYBOX=$(find_busybox)
    if [ -z "$LOCAL_BUSYBOX" ]; then 
        echo "[!] Error: Busybox not found even after download attempt."; exit 1
    fi
    
    echo "[+] Creating structure..."
    mkdir -p "$TERMUX_USR" "$TERMUX_HOME"
    mkdir -p "$TERMUX_CACHE/apt/archives/partial"
    mkdir -p "$TERMUX_USR/var/lib/dpkg/triggers"
    mkdir -p "$TERMUX_USR/var/lib/dpkg/info"
    mkdir -p "$TERMUX_USR/var/lib/dpkg/updates"
    touch "$TERMUX_USR/var/lib/dpkg/status" "$TERMUX_USR/var/lib/dpkg/available"
    
    BOOTSTRAP_FILE="$HOME/.termux-sandbox/bootstrap.zip"
    mkdir -p "$HOME/.termux-sandbox"

    if [ ! -f "$BOOTSTRAP_FILE" ]; then
        echo "[+] Downloading Bootstrap..."
        curl -L $(get_bootstrap_url) -o "$BOOTSTRAP_FILE" --fail || exit 1
    fi
    
    echo "[+] Extracting..."
    unzip -o -q "$BOOTSTRAP_FILE" -d "$TERMUX_USR"
    restore_symlinks "$TERMUX_USR"
    chmod -R 755 "$TERMUX_USR/bin"
    if [ -d "$TERMUX_USR/lib/apt/methods" ]; then chmod -R 755 "$TERMUX_USR/lib/apt/methods"; fi

    compile_fake_uid
    
    cp "$LOCAL_BUSYBOX" "$SANDBOX_BASE/busybox-static"
    chmod 755 "$SANDBOX_BASE/busybox-static"
    echo "[OK] Sandbox created."
}

cmd_enter() {
    # === 1. Argument Parsing ===
    local TARGET_NAME=""
    local BIND_HOST=false  # Default: Do not mount sensitive host directories (Safety First)

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -b|--bind)
                BIND_HOST=true
                shift
                ;;
            -*)
                echo "[!] Unknown option: $1"
                exit 1
                ;;
            *)
                if [ -z "$TARGET_NAME" ]; then
                    TARGET_NAME="$1"
                fi
                shift
                ;;
        esac
    done

    # If no name provided, use default
    SANDBOX_NAME="${TARGET_NAME:-default}"
    # Update global variable (since script header might have run before we knew the name)
    SANDBOX_BASE="$HOME/.termux-sandbox/$SANDBOX_NAME"
    
    # === 2. Basic Checks ===
    if [ ! -d "$SANDBOX_BASE/data/data/com.termux/files/usr/bin" ]; then 
        echo "[!] Sandbox '$SANDBOX_NAME' not found."; exit 1
    fi

    # Privilege check
    # We need to pass the arguments back to tsu so the recursive call knows about -b
    if [ "$(id -u)" != "0" ]; then 
        OPTS=""
        if [ "$BIND_HOST" = true ]; then OPTS="-b"; fi
        $(realpath "$0") enter $OPTS $SANDBOX_NAME
        exit $?
    fi

    echo "[+] [ROOT] Entering sandbox: $SANDBOX_NAME"
    if [ "$BIND_HOST" = true ]; then
        echo "    Mode: UNRESTRICTED (Host Mounted)"
    else
        echo "    Mode: SAFE (Isolated)"
    fi

    # Pre-define variables for cleanup
    CHROOT_ROOT="$SANDBOX_BASE"
    MOUNT_BIN="/system/bin/mount"

    # ================= SAFETY TRAP =================
    # Define cleanup function: will be executed regardless of exit (crash, Ctrl+C, or success)
    cleanup_mounts() {
        # Prevent interruption during cleanup
        trap '' EXIT INT TERM
        
        # Uncomment the next line if you want to see cleanup logs
        # echo "[*] Cleaning up mounts..."
        
        # Unmount mount points in reverse order (sort -r ensures subdirectories are unmounted first)
        grep "$SANDBOX_BASE" /proc/mounts | awk '{print $2}' | sort -r | xargs -r umount -l 2>/dev/null
        
        # Delete temporary files
        rm -f "$CHROOT_ROOT/busybox_static" "$CHROOT_ROOT/entry.sh"
    }

    # Register signal traps: EXIT (normal exit), INT (Ctrl+C), TERM (termination signal)
    trap cleanup_mounts EXIT INT TERM
    # ===============================================

    REPO_IP=$(resolve_ip "$TARGET_DOMAIN")
    [ -z "$REPO_IP" ] && REPO_IP="104.21.57.147"
    DNS_SERVER=$(check_dns)
    
    SOURCES_LIST="$SANDBOX_BASE/data/data/com.termux/files/usr/etc/apt/sources.list"
    echo "deb https://$TARGET_DOMAIN/apt/termux-main stable main" > "$SOURCES_LIST"
    rm -f "$SANDBOX_BASE/data/data/com.termux/files/usr/etc/apt/apt.conf.d/99-trust-all"

    cp "$SANDBOX_BASE/busybox-static" "$CHROOT_ROOT/busybox_static"
    chmod 755 "$CHROOT_ROOT/busybox_static"

    # === BASE SYSTEM MOUNTS (Essential) ===
    # Mount necessary directories for the sandbox OS to function
    ABS_BASE=$(realpath "$HOME/.termux-sandbox")
    
    for item in /*; do
        name=$(basename "$item")
        ABS_ITEM=$(realpath "$item")
        if [[ "$ABS_BASE" == "$ABS_ITEM"* ]]; then
            continue
        fi
        [[ "$name" == "etc" ]] && continue
        
        # Skip sensitive directories here.
        # They will be handled later in the OPTIONAL section based on flags.
        case "$name" in
            sdcard|storage|host_root) continue ;; 
        esac
        
        if [ -L "$item" ]; then
            target=$(readlink "$item")
            rm -f "$CHROOT_ROOT/$name"
            ln -sf "$target" "$CHROOT_ROOT/$name"
        elif [ -d "$item" ]; then
            case "$name" in
                data|mnt|dev|proc|sys) ;; 
                *)
                    mkdir -p "$CHROOT_ROOT/$name"
                    $MOUNT_BIN --rbind "$item" "$CHROOT_ROOT/$name" ;;
            esac
        fi
    done

    mkdir -p "$CHROOT_ROOT/dev" "$CHROOT_ROOT/proc" "$CHROOT_ROOT/sys"
    $MOUNT_BIN --bind /dev "$CHROOT_ROOT/dev"
    $MOUNT_BIN --bind /dev/pts "$CHROOT_ROOT/dev/pts"
    $MOUNT_BIN --bind /proc "$CHROOT_ROOT/proc"
    $MOUNT_BIN --bind /sys "$CHROOT_ROOT/sys"
    
    mkdir -p "$CHROOT_ROOT/system"
    $MOUNT_BIN --rbind /system "$CHROOT_ROOT/system"

    # === OPTIONAL HOST MOUNTS ===
    if [ "$BIND_HOST" = true ]; then
        # Only execute if -b / --bind is passed
        
        # --- 1. HOST ROOT ---
        # Strategy: Use tmpfs to avoid creating folders on real partition
        mkdir -p "$CHROOT_ROOT/host_root"
        $MOUNT_BIN -t tmpfs tmpfs "$CHROOT_ROOT/host_root"
        
        # echo "[*] Mirroring Host Root..."
        for item in /*; do
            name=$(basename "$item")
            if [ -d "$item" ]; then
                mkdir -p "$CHROOT_ROOT/host_root/$name"
                $MOUNT_BIN --rbind "$item" "$CHROOT_ROOT/host_root/$name"
            fi
        done
        
        # --- 2. SDCARD ---
        rm -rf "$CHROOT_ROOT/sdcard"
        mkdir -p "$CHROOT_ROOT/sdcard"
        if [ -d "/data/media/0" ]; then
            $MOUNT_BIN --bind "/data/media/0" "$CHROOT_ROOT/sdcard"
        else
            $MOUNT_BIN --bind "/sdcard" "$CHROOT_ROOT/sdcard"
        fi
    else
        # Safe Mode: Ensure these directories are empty or non-existent
        rm -rf "$CHROOT_ROOT/sdcard" "$CHROOT_ROOT/host_root"
    fi
    # ========================================

    # === ETC & NETWORKING ===
    $MOUNT_BIN -t tmpfs tmpfs "$CHROOT_ROOT/system/etc"
    echo "127.0.0.1 localhost" > "$CHROOT_ROOT/system/etc/hosts"
    echo "$REPO_IP $TARGET_DOMAIN" >> "$CHROOT_ROOT/system/etc/hosts"
    echo "nameserver $DNS_SERVER" > "$CHROOT_ROOT/system/etc/resolv.conf"
    
    chmod 755 "$CHROOT_ROOT/system/etc"
    chmod 644 "$CHROOT_ROOT/system/etc/hosts"
    
    [ -d "/system/etc/security" ] && { mkdir -p "$CHROOT_ROOT/system/etc/security"; $MOUNT_BIN --bind "/system/etc/security" "$CHROOT_ROOT/system/etc/security"; }
    
    mkdir -p "$CHROOT_ROOT/etc"
    echo "root:x:0:0:root:/root:/bin/sh" > "$CHROOT_ROOT/etc/passwd"
    echo "termux:x:10000:10000:Termux User:/data/data/com.termux/files/home:/data/data/com.termux/files/usr/bin/bash" >> "$CHROOT_ROOT/etc/passwd"
    echo "root:x:0:" > "$CHROOT_ROOT/etc/group"
    echo "termux:x:10000:" >> "$CHROOT_ROOT/etc/group"
    
    cp "$CHROOT_ROOT/system/etc/resolv.conf" "$CHROOT_ROOT/etc/resolv.conf"
    cp "$CHROOT_ROOT/system/etc/hosts" "$CHROOT_ROOT/etc/hosts"

    cat > "$CHROOT_ROOT/entry.sh" <<EOF
#!/busybox_static sh
TERMUX_USR="/data/data/com.termux/files/usr"
TERMUX_BASH="\$TERMUX_USR/bin/bash"
export PATH=/busybox_static:\$TERMUX_USR/bin:/system/bin
export HOME="/data/data/com.termux/files/home"
export TERM=xterm-256color
export TMPDIR=\$TERMUX_USR/tmp
export SSL_CERT_FILE=\$TERMUX_USR/etc/tls/cert.pem
export SSL_CERT_DIR=/system/etc/security/cacerts
FAKE_LIB="\$TERMUX_USR/lib/libfakeuid.so"

echo "----------------------------------------"
echo "[*] Sandbox: $SANDBOX_NAME"
if [ "$BIND_HOST" = true ]; then
    echo "WARNING: /sdcard and /host_root are ACCESSIBLE."
else
    echo "NOTE: Running in isolated mode (No /sdcard access)."
fi
echo "----------------------------------------"

if [ -x "\$TERMUX_BASH" ]; then
    export LD_PRELOAD="\$FAKE_LIB"
    exec \$TERMUX_BASH -l
else
    exec /busybox_static sh
fi
EOF
    chmod 755 "$CHROOT_ROOT/entry.sh"

    chroot "$CHROOT_ROOT" /busybox_static sh /entry.sh
}

cmd_delete() {
    # 1. Root privilege check
    if [ "$(id -u)" != "0" ]; then $(realpath "$0") delete $SANDBOX_NAME; exit $?; fi
    
    # 2. Check if the sandbox directory exists
    if [ ! -d "$SANDBOX_BASE" ]; then
        echo "[!] Sandbox '$SANDBOX_NAME' not found."
        return
    fi

    echo "[*] Deleting sandbox: $SANDBOX_NAME"

    # 3. Attempt to unmount filesystems (multiple tries to ensure stubborn mounts are detached)
    # Loop 3 times to prevent lazy unmount from being incomplete
    for i in 1 2 3; do
        if grep -q "$SANDBOX_BASE" /proc/mounts; then
            echo "    - Unmounting filesystems (Attempt $i)..."
            grep "$SANDBOX_BASE" /proc/mounts | awk '{print $2}' | sort -r | xargs -r umount -l 2>/dev/null
            sleep 0.5
        else
            break
        fi
    done

    # 4. [CRITICAL SAFETY CHECK] Re-check for any remaining mounts
    # If grep still finds the sandbox path, it means unmounting failed.
    # ABSOLUTELY DO NOT EXECUTE rm -rf AT THIS POINT!!!
    if grep -q "$SANDBOX_BASE" /proc/mounts; then
        echo " "
        echo "‚ùå [CRITICAL ERROR] Unmount failed!"
        echo "  Filesystem is still mounted. Aborting delete to protect host data."
        echo "  Please close all sandbox sessions and try again."
        echo "  Debug: check 'cat /proc/mounts | grep $SANDBOX_NAME'"
        exit 1
    fi

    # 5. Only execute deletion after confirming no mounts remain
    rm -rf "$SANDBOX_BASE"
    echo "[+] Sandbox deleted successfully."
}

cmd_rename() {
    local OLD_NAME="$1"
    local NEW_NAME="$2"

    if [ -z "$OLD_NAME" ] || [ -z "$NEW_NAME" ]; then
        echo "Usage: $(basename "$0") rename <old_name> <new_name>"
        return
    fi

    local OLD_DIR="$HOME/.termux-sandbox/$OLD_NAME"
    local NEW_DIR="$HOME/.termux-sandbox/$NEW_NAME"

    # 1. Check if source exists
    if [ ! -d "$OLD_DIR" ]; then
        echo "[!] Sandbox '$OLD_NAME' not found."
        return
    fi

    # 2. Check if target already exists
    if [ -d "$NEW_DIR" ]; then
        echo "[!] A sandbox named '$NEW_NAME' already exists."
        return
    fi

    # 3. SAFETY CHECK: Ensure sandbox is not active
    # Renaming a directory that has active mounts is dangerous and causes system confusion
    if grep -q "$OLD_DIR" /proc/mounts; then
        echo "[!] Sandbox is active. Please exit/stop it first before renaming."
        return
    fi

    echo "[*] Renaming '$OLD_NAME' to '$NEW_NAME'..."
    mv "$OLD_DIR" "$NEW_DIR"
    
    if [ $? -eq 0 ]; then
        echo "[+] Rename successful."
    else
        echo "[!] Rename failed."
    fi
}

cmd_duplicate() {
    local SRC_NAME="$1"
    local NEW_NAME="$2"

    if [ -z "$SRC_NAME" ] || [ -z "$NEW_NAME" ]; then
        echo "Usage: $(basename "$0") duplicate <source_name> <new_name>"
        return
    fi

    local SRC_DIR="$HOME/.termux-sandbox/$SRC_NAME"
    local NEW_DIR="$HOME/.termux-sandbox/$NEW_NAME"

    # 1. Check if source exists
    if [ ! -d "$SRC_DIR" ]; then
        echo "[!] Source sandbox '$SRC_NAME' not found."
        return
    fi

    # 2. Check if target already exists
    if [ -d "$NEW_DIR" ]; then
        echo "[!] A sandbox named '$NEW_NAME' already exists."
        return
    fi

    # 3. SAFETY CHECK: Ensure source is not active
    # Duplicating an active sandbox would recursively copy /sdcard and /host_root contents
    # causing storage exhaustion and infinite loops.
    if grep -q "$SRC_DIR" /proc/mounts; then
        echo "[!] Sandbox is active. Please exit/stop it first before duplicating."
        return
    fi

    echo "[*] Duplicating '$SRC_NAME' to '$NEW_NAME'..."
    echo "    This may take a while depending on the size..."

    # -p: Preserve mode, ownership, and timestamps (Critical for rootfs)
    # -r: Recursive copy
    cp -p -r "$SRC_DIR" "$NEW_DIR"

    if [ $? -eq 0 ]; then
        echo "[+] Duplicate successful."
    else
        echo "[!] Duplicate failed."
        # Cleanup partial copy if failed
        rm -rf "$NEW_DIR"
    fi
}

cmd_export() {
    local TARGET_NAME="$1"
    local OUTPUT_FILE="$2"

    if [ -z "$TARGET_NAME" ] || [ -z "$OUTPUT_FILE" ]; then
        echo "Usage: $(basename "$0") export <sandbox_name> <output_file.tar.gz>"
        return
    fi

    local SANDBOX_DIR="$HOME/.termux-sandbox/$TARGET_NAME"

    # Resolve absolute path for output file to ensure tar finds it
    local ABS_OUTPUT_PATH=$(realpath "$OUTPUT_FILE")

    # Check if sandbox exists
    if [ ! -d "$SANDBOX_DIR" ]; then
        echo "[!] Sandbox '$TARGET_NAME' not found."
        return
    fi

    # Check if sandbox is currently active (must stop before export)
    if grep -q "$SANDBOX_DIR" /proc/mounts; then
        echo "[!] Sandbox is active. Please exit/stop it first."
        return
    fi

    echo "[*] Exporting sandbox: $TARGET_NAME"
    echo "    Source: $SANDBOX_DIR"
    echo "    Output: $ABS_OUTPUT_PATH"

    # Clean APT cache to reduce archive size
    local APT_CACHE="$SANDBOX_DIR/data/data/com.termux/files/usr/var/cache/apt/archives"
    if [ -d "$APT_CACHE" ]; then
        echo "[*] Cleaning APT cache to save space..."
        rm -f "$APT_CACHE"/*.deb
        rm -f "$APT_CACHE/partial"/*
    fi

    # Compress the sandbox
    # Using tsu to preserve root/10000 ownership
    # --exclude: Exclude runtime files, mount points, and temp files
    echo "[*] Compressing..."
    
    # Get the parent directory (e.g., /.../.termux-sandbox)
    local PARENT_DIR=$(dirname "$SANDBOX_DIR")
    local DIR_NAME=$(basename "$SANDBOX_DIR")

    # Use a subshell to change directory safely without affecting the main script
    (
        cd "$PARENT_DIR" || exit 1
        tar czvf "$ABS_OUTPUT_PATH" \
            --exclude="$DIR_NAME/entry.sh" \
            --exclude="$DIR_NAME/busybox_static" \
            --exclude="$DIR_NAME/sdcard/*" \
            --exclude="$DIR_NAME/host_root/*" \
            --exclude="$DIR_NAME/data/data/com.termux/files/usr/tmp/*" \
            "$DIR_NAME"
    )

    if [ $? -eq 0 ]; then
        echo "[+] Export complete: $ABS_OUTPUT_PATH"
    else
        echo "[!] Export failed."
    fi
}

cmd_import() {
    local ARCHIVE_FILE="$1"
    
    if [ -z "$ARCHIVE_FILE" ]; then
        echo "Usage: $(basename "$0") import <file.tar.gz>"
        return
    fi
    
    local ABS_ARCHIVE_PATH=$(realpath "$ARCHIVE_FILE")
    
    if [ ! -f "$ABS_ARCHIVE_PATH" ]; then
        echo "[!] File not found: $ARCHIVE_FILE"
        return
    fi

    local BASE_DIR="$HOME/.termux-sandbox"
    mkdir -p "$BASE_DIR"

    echo "[*] Importing from $ABS_ARCHIVE_PATH..."
    
    # Use absolute path and 'tar xzvpf' (no dash)
    tar xzvpf "$ABS_ARCHIVE_PATH" -C "$BASE_DIR"
    
    if [ $? -eq 0 ]; then
        echo "[+] Import complete."
    else
        echo "[!] Import failed."
    fi
}

cmd_list() {
    BASE_DIR="$HOME/.termux-sandbox"
    
    # Check if the base directory exists
    if [ ! -d "$BASE_DIR" ]; then
        echo "[!] No sandboxes found, or tsu environment not detected."
        return
    fi

    # Table header format
    echo
    printf "%-20s | %-10s\n" "SANDBOX NAME" "STATUS"
    echo "---------------------+-----------"

    found=0
    for dir in "$BASE_DIR"/*; do
        # Skip non-directories (e.g., bootstrap.zip)
        [ ! -d "$dir" ] && continue
        
        name=$(basename "$dir")
        found=1
        
        # Check if mounted (to determine if the sandbox is running)
        # If the sandbox path is found in /proc/mounts, it means it hasn't been unmounted yet
        if grep -q "$dir" /proc/mounts; then
            status="üü¢ Active"
        else
            status="‚ö™ Idle"
        fi
        
        printf "%-20s | %s\n" "$name" "$status"
    done

    if [ "$found" -eq 0 ]; then
        echo "       (No sandboxes created)"
    fi
    echo
}

case "$1" in
    create)    shift; cmd_create "$@" ;;
    enter)     shift; cmd_enter "$@"  ;;
    delete)    shift; cmd_delete "$@" ;;
    rename)    shift; cmd_rename "$@" ;;
    duplicate) shift; cmd_duplicate "$@" ;;
    export)    shift; cmd_export "$@" ;;
    import)    shift; cmd_import "$@" ;;
    list)      cmd_list ;;
    *) 
        echo "Usage:"
        echo "  $(basename "$0") create [name]"
        echo "  $(basename "$0") enter [name] [--bind|-b]"
        echo "  $(basename "$0") delete [name]"
        echo "  $(basename "$0") rename <old_name> <new_name>"
        echo "  $(basename "$0") duplicate <src_name> <new_name>"
        echo "  $(basename "$0") export <name> <file.tar.gz>"
        echo "  $(basename "$0") import <file.tar.gz>"
        echo "  $(basename "$0") list"
        exit 1
        ;;
esac