#!/data/data/com.termux/files/usr/bin/bash

# ================= Configuration =================
SANDBOX_NAME="${2:-default}"
SANDBOX_BASE="$HOME/.termux-sandbox/$SANDBOX_NAME"
ARCH=$(dpkg --print-architecture)

BOOTSTRAP_VERSION="bootstrap-2025.11.30-r1%2Bapt.android-7"
BOOTSTRAP_URL_ARM="https://github.com/termux/termux-packages/releases/download/${BOOTSTRAP_VERSION}/bootstrap-arm.zip"
BOOTSTRAP_URL_AARCH64="https://github.com/termux/termux-packages/releases/download/${BOOTSTRAP_VERSION}/bootstrap-aarch64.zip"

BUSYBOX_PATH="$HOME/busybox_arm64"
TARGET_DOMAIN="packages-cf.termux.dev"
# ===============================================

get_bootstrap_url() {
    case "$ARCH" in
        arm) echo "$BOOTSTRAP_URL_ARM" ;;
        aarch64) echo "$BOOTSTRAP_URL_AARCH64" ;;
        *) echo "Unsupported arch: $ARCH"; exit 1 ;;
    esac
}

find_busybox() {
    if [ -f "$BUSYBOX_PATH" ]; then echo "$BUSYBOX_PATH"; return; fi
    SCRIPT_DIR=$(dirname "$(realpath "$0")")
    if [ -f "$SCRIPT_DIR/busybox_arm64" ]; then echo "$SCRIPT_DIR/busybox_arm64"; return; fi
    return 1
}

restore_symlinks() {
    local TARGET_DIR="$1"
    local SYMLINKS_FILE="$TARGET_DIR/SYMLINKS.txt"
    if [ ! -f "$SYMLINKS_FILE" ]; then return; fi
    echo "[+] Restoring symlinks..."
    cd "$TARGET_DIR" || return
    ln -sf coreutils bin/env
    ln -sf bash bin/sh
    awk -F 'â†' '{system("ln -sf " $1 " " $2)}' "$SYMLINKS_FILE" 2>/dev/null
}

resolve_ip() {
    ping -c 1 "$1" 2>/dev/null | grep -oE '\([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+\)' | head -n 1 | tr -d '()'
}

check_dns() {
    if ping -c 1 -W 1 8.8.8.8 >/dev/null 2>&1; then echo "8.8.8.8"; else echo "114.114.114.114"; fi
}

compile_fake_uid() {
    local LIB_DIR="$SANDBOX_BASE/data/data/com.termux/files/usr/lib"
    mkdir -p "$LIB_DIR"
    echo "[*] Compiling UID spoofer..."
    cat > "$SANDBOX_BASE/fake_uid.c" <<EOF
#define _GNU_SOURCE
#include <unistd.h>
#include <sys/types.h>
uid_t getuid(void) { return 10000; }
uid_t geteuid(void) { return 10000; }
gid_t getgid(void) { return 10000; }
gid_t getegid(void) { return 10000; }
EOF
    if command -v clang >/dev/null; then
        clang -shared -fPIC "$SANDBOX_BASE/fake_uid.c" -o "$LIB_DIR/libfakeuid.so"
    elif command -v gcc >/dev/null; then
        gcc -shared -fPIC "$SANDBOX_BASE/fake_uid.c" -o "$LIB_DIR/libfakeuid.so"
    else
        echo "[!] Error: 'clang' or 'gcc' is required on host."
        exit 1
    fi
    rm "$SANDBOX_BASE/fake_uid.c"
}

cmd_create() {
    echo "[*] Creating sandbox: $SANDBOX_NAME"
    TERMUX_USR="$SANDBOX_BASE/data/data/com.termux/files/usr"
    TERMUX_HOME="$SANDBOX_BASE/data/data/com.termux/files/home"
    TERMUX_CACHE="$SANDBOX_BASE/data/data/com.termux/cache"
    
    if [ -d "$TERMUX_USR/bin" ]; then echo "[!] Environment exists."; exit 0; fi
    
    LOCAL_BUSYBOX=$(find_busybox)
    if [ -z "$LOCAL_BUSYBOX" ]; then 
        echo "[!] Error: Busybox not found at $BUSYBOX_PATH"; exit 1
    fi
    
    echo "[+] Creating structure..."
    mkdir -p "$TERMUX_USR" "$TERMUX_HOME"
    mkdir -p "$TERMUX_CACHE/apt/archives/partial"
    mkdir -p "$TERMUX_USR/var/lib/dpkg/triggers"
    mkdir -p "$TERMUX_USR/var/lib/dpkg/info"
    mkdir -p "$TERMUX_USR/var/lib/dpkg/updates"
    touch "$TERMUX_USR/var/lib/dpkg/status" "$TERMUX_USR/var/lib/dpkg/available"
    
    BOOTSTRAP_FILE="$HOME/.termux-sandbox/bootstrap.zip"
    mkdir -p "$HOME/.termux-sandbox"

    if [ ! -f "$BOOTSTRAP_FILE" ]; then
        echo "[+] Downloading Bootstrap..."
        curl -L $(get_bootstrap_url) -o "$BOOTSTRAP_FILE" --fail || exit 1
    fi
    
    echo "[+] Extracting..."
    unzip -o -q "$BOOTSTRAP_FILE" -d "$TERMUX_USR"
    restore_symlinks "$TERMUX_USR"
    chmod -R 755 "$TERMUX_USR/bin"
    if [ -d "$TERMUX_USR/lib/apt/methods" ]; then chmod -R 755 "$TERMUX_USR/lib/apt/methods"; fi

    compile_fake_uid
    
    cp "$LOCAL_BUSYBOX" "$SANDBOX_BASE/busybox-static"
    chmod 755 "$SANDBOX_BASE/busybox-static"
    echo "[OK] Sandbox created."
}

cmd_enter() {
    if [ ! -d "$SANDBOX_BASE/data/data/com.termux/files/usr/bin" ]; then 
        echo "[!] Sandbox not found."; exit 1
    fi

    # Privilege check
    if [ "$(id -u)" != "0" ]; then tsu -c "$(realpath "$0") enter $SANDBOX_NAME"; exit $?; fi

    echo "[+] [ROOT] Entering sandbox: $SANDBOX_NAME"
    
    # Pre-define variable for cleanup use
    CHROOT_ROOT="$SANDBOX_BASE"

    # ================= SAFETY TRAP =================
    # Define cleanup function: will be executed regardless of exit
    cleanup_mounts() {
        # Prevent interruption during cleanup
        trap '' EXIT INT TERM
        
        echo
        echo "[*] Cleaning up mounts..."
        
        # Unmount mount points in reverse order (sort -r ensures subdirectories are unmounted first)
        grep "$SANDBOX_BASE" /proc/mounts | awk '{print $2}' | sort -r | xargs -r umount -l 2>/dev/null
        
        # Delete temporary files
        rm -f "$CHROOT_ROOT/busybox_static" "$CHROOT_ROOT/entry.sh"
    }

    # Register signal traps: EXIT (normal exit), INT (Ctrl+C), TERM (termination signal)
    trap cleanup_mounts EXIT INT TERM
    # =========================================================

    REPO_IP=$(resolve_ip "$TARGET_DOMAIN")
    [ -z "$REPO_IP" ] && REPO_IP="104.21.57.147"
    DNS_SERVER=$(check_dns)
    
    SOURCES_LIST="$SANDBOX_BASE/data/data/com.termux/files/usr/etc/apt/sources.list"
    echo "deb https://$TARGET_DOMAIN/apt/termux-main stable main" > "$SOURCES_LIST"
    rm -f "$SANDBOX_BASE/data/data/com.termux/files/usr/etc/apt/apt.conf.d/99-trust-all"

    MOUNT_BIN="/system/bin/mount"
    
    cp "$SANDBOX_BASE/busybox-static" "$CHROOT_ROOT/busybox_static"
    chmod 755 "$CHROOT_ROOT/busybox_static"

    # === BASE SYSTEM MOUNTS ===
    # Mount necessary directories for the sandbox OS to function
    for item in /*; do
        name=$(basename "$item")
        [[ "$HOME/.termux-sandbox" == *"$name"* ]] && continue
        [[ "$name" == "etc" ]] && continue
        
        case "$name" in
            sdcard|storage) continue ;;
        esac

        if [ -L "$item" ]; then
            target=$(readlink "$item")
            rm -f "$CHROOT_ROOT/$name"
            ln -sf "$target" "$CHROOT_ROOT/$name"
        elif [ -d "$item" ]; then
            case "$name" in
                data|mnt|dev|proc|sys) ;; 
                *)
                    mkdir -p "$CHROOT_ROOT/$name"
                    $MOUNT_BIN --rbind "$item" "$CHROOT_ROOT/$name" ;;
            esac
        fi
    done

    mkdir -p "$CHROOT_ROOT/dev" "$CHROOT_ROOT/proc" "$CHROOT_ROOT/sys"
    $MOUNT_BIN --bind /dev "$CHROOT_ROOT/dev"
    $MOUNT_BIN --bind /dev/pts "$CHROOT_ROOT/dev/pts"
    $MOUNT_BIN --bind /proc "$CHROOT_ROOT/proc"
    $MOUNT_BIN --bind /sys "$CHROOT_ROOT/sys"
    
    mkdir -p "$CHROOT_ROOT/system"
    $MOUNT_BIN --rbind /system "$CHROOT_ROOT/system"

    # === FIXED HOST ROOT (Mirror Strategy) ===
    # 1. Clean existing host_root
    mkdir -p "$CHROOT_ROOT/host_root"
    
    # 2. Mount a TMPFS (RAM Disk) to /host_root
    # This allows us to create mountpoints without modifying actual storage
    $MOUNT_BIN -t tmpfs tmpfs "$CHROOT_ROOT/host_root"
    
    echo "[*] Mirroring Host Root to /host_root..."
    # 3. Iterate through every item in Host Root
    for item in /*; do
        name=$(basename "$item")
        # Check if it's a directory (we only mirror directories)
        if [ -d "$item" ]; then
            # Create the folder in our tmpfs
            mkdir -p "$CHROOT_ROOT/host_root/$name"
            # RECURSIVE BIND (--rbind) is crucial here!
            $MOUNT_BIN --rbind "$item" "$CHROOT_ROOT/host_root/$name"
        fi
    done
    # =========================================

    # === FIXED SDCARD (Direct Mount) ===
    rm -rf "$CHROOT_ROOT/sdcard"
    mkdir -p "$CHROOT_ROOT/sdcard"
    if [ -d "/data/media/0" ]; then
        $MOUNT_BIN --bind "/data/media/0" "$CHROOT_ROOT/sdcard"
    else
        $MOUNT_BIN --bind "/sdcard" "$CHROOT_ROOT/sdcard"
    fi

    # === ETC & NETWORKING ===
    $MOUNT_BIN -t tmpfs tmpfs "$CHROOT_ROOT/system/etc"
    echo "127.0.0.1 localhost" > "$CHROOT_ROOT/system/etc/hosts"
    echo "$REPO_IP $TARGET_DOMAIN" >> "$CHROOT_ROOT/system/etc/hosts"
    echo "nameserver $DNS_SERVER" > "$CHROOT_ROOT/system/etc/resolv.conf"
    
    chmod 755 "$CHROOT_ROOT/system/etc"
    chmod 644 "$CHROOT_ROOT/system/etc/hosts"
    
    [ -d "/system/etc/security" ] && { mkdir -p "$CHROOT_ROOT/system/etc/security"; $MOUNT_BIN --bind "/system/etc/security" "$CHROOT_ROOT/system/etc/security"; }
    
    mkdir -p "$CHROOT_ROOT/etc"
    echo "root:x:0:0:root:/root:/bin/sh" > "$CHROOT_ROOT/etc/passwd"
    echo "termux:x:10000:10000:Termux User:/data/data/com.termux/files/home:/data/data/com.termux/files/usr/bin/bash" >> "$CHROOT_ROOT/etc/passwd"
    echo "root:x:0:" > "$CHROOT_ROOT/etc/group"
    echo "termux:x:10000:" >> "$CHROOT_ROOT/etc/group"
    
    cp "$CHROOT_ROOT/system/etc/resolv.conf" "$CHROOT_ROOT/etc/resolv.conf"
    cp "$CHROOT_ROOT/system/etc/hosts" "$CHROOT_ROOT/etc/hosts"

    cat > "$CHROOT_ROOT/entry.sh" <<EOF
#!/busybox_static sh
TERMUX_USR="/data/data/com.termux/files/usr"
TERMUX_BASH="\$TERMUX_USR/bin/bash"
export PATH=/busybox_static:\$TERMUX_USR/bin:/system/bin
export HOME="/data/data/com.termux/files/home"
export TERM=xterm-256color
export TMPDIR=\$TERMUX_USR/tmp
export SSL_CERT_FILE=\$TERMUX_USR/etc/tls/cert.pem
export SSL_CERT_DIR=/system/etc/security/cacerts
FAKE_LIB="\$TERMUX_USR/lib/libfakeuid.so"

echo "----------------------------------------"
echo "[*] Sandbox: $SANDBOX_NAME"
echo "[*] /host_root: Full Access (Recursive)"
echo "----------------------------------------"

if [ -x "\$TERMUX_BASH" ]; then
    export LD_PRELOAD="\$FAKE_LIB"
    exec \$TERMUX_BASH -l
else
    exec /busybox_static sh
fi
EOF
    chmod 755 "$CHROOT_ROOT/entry.sh"

    chroot "$CHROOT_ROOT" /busybox_static sh /entry.sh
}

cmd_delete() {
    if [ "$(id -u)" != "0" ]; then tsu -c "$(realpath "$0") delete $SANDBOX_NAME"; exit $?; fi
    grep "$SANDBOX_BASE" /proc/mounts | awk '{print $2}' | sort -r | xargs -r umount -l 2>/dev/null
    if [ -d "$SANDBOX_BASE" ]; then rm -rf "$SANDBOX_BASE"; echo "[+] Deleted."; else echo "[!] Sandbox not found."; fi
}

cmd_list() {
    BASE_DIR="$HOME/.termux-sandbox"
    
    # Check if the base directory exists
    if [ ! -d "$BASE_DIR" ]; then
        echo "[!] No sandboxes found, or tsu environment not detected."
        return
    fi

    # Table header format
    echo
    printf "%-20s | %-10s\n" "SANDBOX NAME" "STATUS"
    echo "---------------------+-----------"

    found=0
    for dir in "$BASE_DIR"/*; do
        # Skip non-directories (e.g., bootstrap.zip)
        [ ! -d "$dir" ] && continue
        
        name=$(basename "$dir")
        found=1
        
        # Check if mounted (to determine if the sandbox is running)
        # If the sandbox path is found in /proc/mounts, it means it hasn't been unmounted yet
        if grep -q "$dir" /proc/mounts; then
            status="ðŸŸ¢ Active"
        else
            status="âšª Idle"
        fi
        
        printf "%-20s | %s\n" "$name" "$status"
    done

    if [ "$found" -eq 0 ]; then
        echo "       (No sandboxes created)"
    fi
    echo
}

case "$1" in
    create) cmd_create ;;
    enter)  cmd_enter ;;
    delete) cmd_delete ;;
    list)   cmd_list ;;
    *)
        echo "Usage: "
        echo "  $(basename "$0") {create|enter|delete} [name]"
        echo "  $(basename "$0") list"
        exit 1
        ;;
esac