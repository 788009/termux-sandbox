#!/data/data/com.termux/files/usr/bin/bash

# ================= Configuration =================
SANDBOX_NAME="${2:-default}"
SANDBOX_BASE="$HOME/.termux-sandbox/$SANDBOX_NAME"
ARCH=$(dpkg --print-architecture)

BOOTSTRAP_VERSION="bootstrap-2025.11.30-r1%2Bapt.android-7"
BOOTSTRAP_URL_ARM="https://github.com/termux/termux-packages/releases/download/${BOOTSTRAP_VERSION}/bootstrap-arm.zip"
BOOTSTRAP_URL_AARCH64="https://github.com/termux/termux-packages/releases/download/${BOOTSTRAP_VERSION}/bootstrap-aarch64.zip"

BUSYBOX_PATH="$HOME/busybox_arm64"
TARGET_DOMAIN="packages-cf.termux.dev"
# ===============================================

get_bootstrap_url() {
    case "$ARCH" in
        arm) echo "$BOOTSTRAP_URL_ARM" ;;
        aarch64) echo "$BOOTSTRAP_URL_AARCH64" ;;
        *) echo "Unsupported arch: $ARCH"; exit 1 ;;
    esac
}

find_busybox() {
    if [ -f "$BUSYBOX_PATH" ]; then echo "$BUSYBOX_PATH"; return; fi
    SCRIPT_DIR=$(dirname "$(realpath "$0")")
    if [ -f "$SCRIPT_DIR/busybox_arm64" ]; then echo "$SCRIPT_DIR/busybox_arm64"; return; fi
    return 1
}

restore_symlinks() {
    local TARGET_DIR="$1"
    local SYMLINKS_FILE="$TARGET_DIR/SYMLINKS.txt"
    if [ ! -f "$SYMLINKS_FILE" ]; then return; fi
    echo "[+] Restoring symlinks..."
    cd "$TARGET_DIR" || return
    ln -sf coreutils bin/env
    ln -sf bash bin/sh
    awk -F '‚Üê' '{system("ln -sf " $1 " " $2)}' "$SYMLINKS_FILE" 2>/dev/null
}

resolve_ip() {
    ping -c 1 "$1" 2>/dev/null | grep -oE '\([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+\)' | head -n 1 | tr -d '()'
}

check_dns() {
    if ping -c 1 -W 1 8.8.8.8 >/dev/null 2>&1; then echo "8.8.8.8"; else echo "114.114.114.114"; fi
}

compile_fake_uid() {
    local LIB_DIR="$SANDBOX_BASE/data/data/com.termux/files/usr/lib"
    mkdir -p "$LIB_DIR"
    echo "[*] Compiling UID spoofer..."
    cat > "$SANDBOX_BASE/fake_uid.c" <<EOF
#define _GNU_SOURCE
#include <unistd.h>
#include <sys/types.h>
uid_t getuid(void) { return 10000; }
uid_t geteuid(void) { return 10000; }
gid_t getgid(void) { return 10000; }
gid_t getegid(void) { return 10000; }
EOF
    if command -v clang >/dev/null; then
        clang -shared -fPIC "$SANDBOX_BASE/fake_uid.c" -o "$LIB_DIR/libfakeuid.so"
    elif command -v gcc >/dev/null; then
        gcc -shared -fPIC "$SANDBOX_BASE/fake_uid.c" -o "$LIB_DIR/libfakeuid.so"
    else
        echo "[!] Error: 'clang' or 'gcc' is required on host."
        exit 1
    fi
    rm "$SANDBOX_BASE/fake_uid.c"
}

cmd_create() {
    echo "[*] Creating sandbox: $SANDBOX_NAME"
    TERMUX_USR="$SANDBOX_BASE/data/data/com.termux/files/usr"
    TERMUX_HOME="$SANDBOX_BASE/data/data/com.termux/files/home"
    TERMUX_CACHE="$SANDBOX_BASE/data/data/com.termux/cache"
    
    if [ -d "$TERMUX_USR/bin" ]; then echo "[!] Environment exists."; exit 0; fi
    
    LOCAL_BUSYBOX=$(find_busybox)
    if [ -z "$LOCAL_BUSYBOX" ]; then 
        echo "[!] Error: Busybox not found at $BUSYBOX_PATH"; exit 1
    fi
    
    echo "[+] Creating structure..."
    mkdir -p "$TERMUX_USR" "$TERMUX_HOME"
    mkdir -p "$TERMUX_CACHE/apt/archives/partial"
    mkdir -p "$TERMUX_USR/var/lib/dpkg/triggers"
    mkdir -p "$TERMUX_USR/var/lib/dpkg/info"
    mkdir -p "$TERMUX_USR/var/lib/dpkg/updates"
    touch "$TERMUX_USR/var/lib/dpkg/status" "$TERMUX_USR/var/lib/dpkg/available"
    
    BOOTSTRAP_FILE="$HOME/.termux-sandbox/bootstrap.zip"
    mkdir -p "$HOME/.termux-sandbox"

    if [ ! -f "$BOOTSTRAP_FILE" ]; then
        echo "[+] Downloading Bootstrap..."
        curl -L $(get_bootstrap_url) -o "$BOOTSTRAP_FILE" --fail || exit 1
    fi
    
    echo "[+] Extracting..."
    unzip -o -q "$BOOTSTRAP_FILE" -d "$TERMUX_USR"
    restore_symlinks "$TERMUX_USR"
    chmod -R 755 "$TERMUX_USR/bin"
    if [ -d "$TERMUX_USR/lib/apt/methods" ]; then chmod -R 755 "$TERMUX_USR/lib/apt/methods"; fi

    compile_fake_uid
    
    cp "$LOCAL_BUSYBOX" "$SANDBOX_BASE/busybox-static"
    chmod 755 "$SANDBOX_BASE/busybox-static"
    echo "[OK] Sandbox created."
}

cmd_enter() {
    # === 1. Argument Parsing ===
    local TARGET_NAME=""
    local BIND_HOST=false  # Default: Do not mount sensitive host directories (Safety First)

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -b|--bind)
                BIND_HOST=true
                shift
                ;;
            -*)
                echo "[!] Unknown option: $1"
                exit 1
                ;;
            *)
                if [ -z "$TARGET_NAME" ]; then
                    TARGET_NAME="$1"
                fi
                shift
                ;;
        esac
    done

    # If no name provided, use default
    SANDBOX_NAME="${TARGET_NAME:-default}"
    # Update global variable (since script header might have run before we knew the name)
    SANDBOX_BASE="$HOME/.termux-sandbox/$SANDBOX_NAME"
    
    # === 2. Basic Checks ===
    if [ ! -d "$SANDBOX_BASE/data/data/com.termux/files/usr/bin" ]; then 
        echo "[!] Sandbox '$SANDBOX_NAME' not found."; exit 1
    fi

    # Privilege check
    # We need to pass the arguments back to tsu so the recursive call knows about -b
    if [ "$(id -u)" != "0" ]; then 
        OPTS=""
        if [ "$BIND_HOST" = true ]; then OPTS="-b"; fi
        tsu -c "$(realpath "$0") enter $OPTS $SANDBOX_NAME"
        exit $?
    fi

    echo "[+] [ROOT] Entering sandbox: $SANDBOX_NAME"
    if [ "$BIND_HOST" = true ]; then
        echo "    ‚ö†Ô∏è  Mode: UNRESTRICTED (Host Mounted)"
    else
        echo "    üõ°Ô∏è  Mode: SAFE (Isolated)"
    fi

    # Pre-define variables for cleanup
    CHROOT_ROOT="$SANDBOX_BASE"
    MOUNT_BIN="/system/bin/mount"

    # ================= SAFETY TRAP =================
    # Define cleanup function: will be executed regardless of exit (crash, Ctrl+C, or success)
    cleanup_mounts() {
        # Prevent interruption during cleanup
        trap '' EXIT INT TERM
        
        # Uncomment the next line if you want to see cleanup logs
        # echo "[*] Cleaning up mounts..."
        
        # Unmount mount points in reverse order (sort -r ensures subdirectories are unmounted first)
        grep "$SANDBOX_BASE" /proc/mounts | awk '{print $2}' | sort -r | xargs -r umount -l 2>/dev/null
        
        # Delete temporary files
        rm -f "$CHROOT_ROOT/busybox_static" "$CHROOT_ROOT/entry.sh"
    }

    # Register signal traps: EXIT (normal exit), INT (Ctrl+C), TERM (termination signal)
    trap cleanup_mounts EXIT INT TERM
    # ===============================================

    REPO_IP=$(resolve_ip "$TARGET_DOMAIN")
    [ -z "$REPO_IP" ] && REPO_IP="104.21.57.147"
    DNS_SERVER=$(check_dns)
    
    SOURCES_LIST="$SANDBOX_BASE/data/data/com.termux/files/usr/etc/apt/sources.list"
    echo "deb https://$TARGET_DOMAIN/apt/termux-main stable main" > "$SOURCES_LIST"
    rm -f "$SANDBOX_BASE/data/data/com.termux/files/usr/etc/apt/apt.conf.d/99-trust-all"

    cp "$SANDBOX_BASE/busybox-static" "$CHROOT_ROOT/busybox_static"
    chmod 755 "$CHROOT_ROOT/busybox_static"

    # === BASE SYSTEM MOUNTS (Essential) ===
    # Mount necessary directories for the sandbox OS to function
    for item in /*; do
        name=$(basename "$item")
        [[ "$HOME/.termux-sandbox" == *"$name"* ]] && continue
        [[ "$name" == "etc" ]] && continue
        
        # Skip sensitive directories here.
        # They will be handled later in the OPTIONAL section based on flags.
        case "$name" in
            sdcard|storage|host_root) continue ;; 
        esac
        
        if [ -L "$item" ]; then
            target=$(readlink "$item")
            rm -f "$CHROOT_ROOT/$name"
            ln -sf "$target" "$CHROOT_ROOT/$name"
        elif [ -d "$item" ]; then
            case "$name" in
                data|mnt|dev|proc|sys) ;; 
                *)
                    mkdir -p "$CHROOT_ROOT/$name"
                    $MOUNT_BIN --rbind "$item" "$CHROOT_ROOT/$name" ;;
            esac
        fi
    done

    mkdir -p "$CHROOT_ROOT/dev" "$CHROOT_ROOT/proc" "$CHROOT_ROOT/sys"
    $MOUNT_BIN --bind /dev "$CHROOT_ROOT/dev"
    $MOUNT_BIN --bind /dev/pts "$CHROOT_ROOT/dev/pts"
    $MOUNT_BIN --bind /proc "$CHROOT_ROOT/proc"
    $MOUNT_BIN --bind /sys "$CHROOT_ROOT/sys"
    
    mkdir -p "$CHROOT_ROOT/system"
    $MOUNT_BIN --rbind /system "$CHROOT_ROOT/system"

    # === OPTIONAL HOST MOUNTS ===
    if [ "$BIND_HOST" = true ]; then
        # Only execute if -b / --bind is passed
        
        # --- 1. HOST ROOT ---
        # Strategy: Use tmpfs to avoid creating folders on real partition
        mkdir -p "$CHROOT_ROOT/host_root"
        $MOUNT_BIN -t tmpfs tmpfs "$CHROOT_ROOT/host_root"
        
        # echo "[*] Mirroring Host Root..."
        for item in /*; do
            name=$(basename "$item")
            if [ -d "$item" ]; then
                mkdir -p "$CHROOT_ROOT/host_root/$name"
                $MOUNT_BIN --rbind "$item" "$CHROOT_ROOT/host_root/$name"
            fi
        done
        
        # --- 2. SDCARD ---
        rm -rf "$CHROOT_ROOT/sdcard"
        mkdir -p "$CHROOT_ROOT/sdcard"
        if [ -d "/data/media/0" ]; then
            $MOUNT_BIN --bind "/data/media/0" "$CHROOT_ROOT/sdcard"
        else
            $MOUNT_BIN --bind "/sdcard" "$CHROOT_ROOT/sdcard"
        fi
    else
        # Safe Mode: Ensure these directories are empty or non-existent
        rm -rf "$CHROOT_ROOT/sdcard" "$CHROOT_ROOT/host_root"
    fi
    # ========================================

    # === ETC & NETWORKING ===
    $MOUNT_BIN -t tmpfs tmpfs "$CHROOT_ROOT/system/etc"
    echo "127.0.0.1 localhost" > "$CHROOT_ROOT/system/etc/hosts"
    echo "$REPO_IP $TARGET_DOMAIN" >> "$CHROOT_ROOT/system/etc/hosts"
    echo "nameserver $DNS_SERVER" > "$CHROOT_ROOT/system/etc/resolv.conf"
    
    chmod 755 "$CHROOT_ROOT/system/etc"
    chmod 644 "$CHROOT_ROOT/system/etc/hosts"
    
    [ -d "/system/etc/security" ] && { mkdir -p "$CHROOT_ROOT/system/etc/security"; $MOUNT_BIN --bind "/system/etc/security" "$CHROOT_ROOT/system/etc/security"; }
    
    mkdir -p "$CHROOT_ROOT/etc"
    echo "root:x:0:0:root:/root:/bin/sh" > "$CHROOT_ROOT/etc/passwd"
    echo "termux:x:10000:10000:Termux User:/data/data/com.termux/files/home:/data/data/com.termux/files/usr/bin/bash" >> "$CHROOT_ROOT/etc/passwd"
    echo "root:x:0:" > "$CHROOT_ROOT/etc/group"
    echo "termux:x:10000:" >> "$CHROOT_ROOT/etc/group"
    
    cp "$CHROOT_ROOT/system/etc/resolv.conf" "$CHROOT_ROOT/etc/resolv.conf"
    cp "$CHROOT_ROOT/system/etc/hosts" "$CHROOT_ROOT/etc/hosts"

    cat > "$CHROOT_ROOT/entry.sh" <<EOF
#!/busybox_static sh
TERMUX_USR="/data/data/com.termux/files/usr"
TERMUX_BASH="\$TERMUX_USR/bin/bash"
export PATH=/busybox_static:\$TERMUX_USR/bin:/system/bin
export HOME="/data/data/com.termux/files/home"
export TERM=xterm-256color
export TMPDIR=\$TERMUX_USR/tmp
export SSL_CERT_FILE=\$TERMUX_USR/etc/tls/cert.pem
export SSL_CERT_DIR=/system/etc/security/cacerts
FAKE_LIB="\$TERMUX_USR/lib/libfakeuid.so"

echo "----------------------------------------"
echo "[*] Sandbox: $SANDBOX_NAME"
if [ "$BIND_HOST" = true ]; then
    echo "WARNING: /sdcard and /host_root are ACCESSIBLE."
else
    echo "NOTE: Running in isolated mode (No /sdcard access)."
fi
echo "----------------------------------------"

if [ -x "\$TERMUX_BASH" ]; then
    export LD_PRELOAD="\$FAKE_LIB"
    exec \$TERMUX_BASH -l
else
    exec /busybox_static sh
fi
EOF
    chmod 755 "$CHROOT_ROOT/entry.sh"

    chroot "$CHROOT_ROOT" /busybox_static sh /entry.sh
}

cmd_delete() {
    # 1. Root privilege check
    if [ "$(id -u)" != "0" ]; then tsu -c "$(realpath "$0") delete $SANDBOX_NAME"; exit $?; fi
    
    # 2. Check if the sandbox directory exists
    if [ ! -d "$SANDBOX_BASE" ]; then
        echo "[!] Sandbox '$SANDBOX_NAME' not found."
        return
    fi

    echo "[*] Deleting sandbox: $SANDBOX_NAME"

    # 3. Attempt to unmount filesystems (multiple tries to ensure stubborn mounts are detached)
    # Loop 3 times to prevent lazy unmount from being incomplete
    for i in 1 2 3; do
        if grep -q "$SANDBOX_BASE" /proc/mounts; then
            echo "    - Unmounting filesystems (Attempt $i)..."
            grep "$SANDBOX_BASE" /proc/mounts | awk '{print $2}' | sort -r | xargs -r umount -l 2>/dev/null
            sleep 0.5
        else
            break
        fi
    done

    # 4. [CRITICAL SAFETY CHECK] Re-check for any remaining mounts
    # If grep still finds the sandbox path, it means unmounting failed.
    # ABSOLUTELY DO NOT EXECUTE rm -rf AT THIS POINT!!!
    if grep -q "$SANDBOX_BASE" /proc/mounts; then
        echo " "
        echo "‚ùå [CRITICAL ERROR] Unmount failed!"
        echo "‚ö†Ô∏è  Filesystem is still mounted. Aborting delete to protect host data."
        echo "‚ÑπÔ∏è  Please close all sandbox sessions and try again."
        echo "    Debug: check 'cat /proc/mounts | grep $SANDBOX_NAME'"
        exit 1
    fi

    # 5. Only execute deletion after confirming no mounts remain
    rm -rf "$SANDBOX_BASE"
    echo "[+] Sandbox deleted successfully."
}

cmd_list() {
    BASE_DIR="$HOME/.termux-sandbox"
    
    # Check if the base directory exists
    if [ ! -d "$BASE_DIR" ]; then
        echo "[!] No sandboxes found, or tsu environment not detected."
        return
    fi

    # Table header format
    echo
    printf "%-20s | %-10s\n" "SANDBOX NAME" "STATUS"
    echo "---------------------+-----------"

    found=0
    for dir in "$BASE_DIR"/*; do
        # Skip non-directories (e.g., bootstrap.zip)
        [ ! -d "$dir" ] && continue
        
        name=$(basename "$dir")
        found=1
        
        # Check if mounted (to determine if the sandbox is running)
        # If the sandbox path is found in /proc/mounts, it means it hasn't been unmounted yet
        if grep -q "$dir" /proc/mounts; then
            status="üü¢ Active"
        else
            status="‚ö™ Idle"
        fi
        
        printf "%-20s | %s\n" "$name" "$status"
    done

    if [ "$found" -eq 0 ]; then
        echo "       (No sandboxes created)"
    fi
    echo
}

case "$1" in
    create) shift; cmd_create "$@" ;;
    enter)  shift; cmd_enter "$@"  ;;
    delete) shift; cmd_delete "$@" ;;
    list)   cmd_list ;;
    *) 
        echo "Usage:"
        echo "  $(basename "$0") create [name]"
        echo "  $(basename "$0") enter [name] [--bind|-b]"
        echo "  $(basename "$0") delete [name]"
        echo "  $(basename "$0") list"
        exit 1
        ;;
esac